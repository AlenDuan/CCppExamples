
<!--
<User>
  <luckystar></luckystar>
</User>
<Date>
  <13-9-3></13-9-3>
</Date>
<Time>下午10:04</Time>
--><!DOCTYPE html>
<html lang="en"></html>
<head>
  <meta charset="utf-8">
  <title>Class & Object</title>
  <meta name="author" content="俸志刚">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
  <link rel="stylesheet" href="css/reveal_bigFont.css">
  <link id="theme" rel="stylesheet" href="css/theme/simple.css">
  <link rel="stylesheet" href="../lib/bootstrap/css/bootstrap.min.css">
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>Class & Object</h1><br>
          <h2>(类 与 对象)</h2>
        </section>
        <section>
          <section>
            <h3>Encapsulation</h3><br>
            <h3>(封装)</h3>
          </section>
          <section>
            <h3>【例1】Queue(队列)</h3><br>
            <ul>
              <li class="fragment">append(入队)</li>
              <li class="fragment">pop(出队)</li><br>
              <li class="fragment">队列是否满</li>
              <li class="fragment">队列是否空</li>
            </ul>
          </section>
          <section>
            <h3>使用 Queue类和对象</h3>
            <pre>Queue queue;
if ( !queue.isFull() ) {
    queue.append ( 100 ) ;
}

int n ;
if ( !queue.isEmpty() ) {
    n = queue.pop ( ) ;
}
...
Queue *p = new Queue() ;
p -> append ( 100 ) ;
p = &queue ;
...
</pre>
          </section>
          <section>
            <h3>define/declare(定义/声明）: Queue类 （ Queue.h ）</h3>
            <pre>class Queue{

public:
    void append ( int item ) ;
    int pop ( ) ;
    bool isEmpty ( ) ;
    bool isFull ( ) ;</pre>
            <pre class="fragment">private:
    int data[ 100] ;
    int head = 10 ;
    int tail = 10 ;
};</pre>
          </section>
          <section>
            <h3>implement(实现) Queue类 ( Queue.cpp )</h3>
            <pre>#include “Queue.h”

void Queue::append( int item ){
    data[ head ] = item;
    head = (head+1) % 100;
}
int Queue::pop(){
    tail = ( tail + 1 ) % 100 ;
    return data[ tail-1 ] ;
}
bool Queue::isEmpty(){
    return (head == tail);
};
bool Queue::isFull(){
    return ((head+1)%100 == tail);
};</pre>
          </section>
          <section>
            <h3>【课堂练习7-1】Stack类</h3><br>
            <ul>
              <li>LIFO(后进先出,FILO)</li><br>
              <li>可容纳100个元素(int型)</li><br>
              <li>可判断是否为空</li><br>
              <li>可判断是否已满</li><br>
              <li>push(进栈)操作</li><br>
              <li>pop(出栈)操作</li>
            </ul>
          </section>
        </section>
        <section>
          <section>
            <h3>constructor/deconstuctor</h3><br>
            <h3>(构造/析构)</h3>
          </section>
          <section>
            <h3>改进Stack类</h3><br>
            <h3>初始化的时候确定最大容量</h3>
            <pre>Stack stack(10000);
...</pre>
            <div class="fragment">
              <pre>Stack.h:

class Stack{
public:
    Stack(int capbility);// 构造函数</pre>
            </div>
            <pre class="fragment">private:
    int* data;
};</pre>
          </section>
          <section>
            <pre>在Stack.cpp中实现:

Stack::Stack(int capbility){
    data = new int[capbility];
}</pre><br>
            <div class="fragment">
              <pre>或者直接在Stack.h中实现:

class Stack{
public:
    Stack(int capbility){
        data = new int[capbility];
    }
    ...
}</pre>
            </div>
          </section>
          <section>
            <pre>Point(int x, int y){
    this->x = x;
    this->y = y;
}</pre><br>
            <div class="fragment">
              <pre>利用初始化列表:

Point(int x, int y):x(x),y(y) {}</pre>
            </div>
          </section>
          <section>
            <h3> 单参数构造函数 实例化对象的写法</h3>
            <pre>Stack s(100);
//等价于
Stack s=100;</pre>
          </section>
          <section>
            <pre>void foo(){
    Stack s(10000);
}

???</pre>
            <pre class="fragment">内存泄漏！！！</pre>
          </section>
          <section>
            <pre>class Stack{
    public:
        Stack(int capbility){
            data = new int[capbility];
        }
        ~Stack(){ //析构函数
            delete [] data;
        }
    }
    </pre>
          </section>
          <section>
            <h3>【课堂练习7-2】安全数组(1)</h3><br>
            <ul>
              <li>数组满时，不能追加元素</li><br>
              <li>数组下标越界时，报错！</li>
            </ul>
          </section>
          <section>
            <h3>【课堂练习7-3】安全数组(2)</h3><br>
            <ul>
              <li>数组满时，自动扩容</li>
            </ul>
          </section>
          <section>
            <h3>默认（缺省）构造函数</h3>
            <pre>int main(){
    Point p;
    ...
}
class Point{
public:
    //无构造函数
private:
    int x, y;  //x和y为随机数
};
</pre>
          </section>
          <section>
            <h3>默认（缺省）构造函数</h3>
            <pre>int main(){
    Point p;
    ...
}
class Point{
public:
    //无构造函数
private:
    int x =0 , y = 0;
};
</pre>
          </section>
          <section>
            <h3>默认（缺省）构造函数</h3>
            <pre>int main(){
    Point p;
    ...
}
class Point{
public:
    //有不带参数的构造函数
    Point():x(0),y(0){}
    
private:
    int x , y ;
};
</pre>
          </section>
          <section>
            <h3>默认（缺省）构造函数</h3>
            <pre>int main(){
    Point p;  // 错误！
    ...
}
class Point{
public:
    // 只有带参数构造函数，没有不带参数的构造函数
    Point(int x,int y):x(x),y(y){}
private:
    int x , y ;
};
</pre>
          </section>
          <section>
            <h3>How about 默认析构函数？</h3>
          </section>
        </section>
        <section>
          <section>
            <h3>this 指针</h3>
            <pre>class Point{
public:
    Point(int x,int y){
        this->x = x;
        this->y = y;
    }
private:
    int x , y ;
};
</pre>
          </section>
          <section>
            <h3>this 指针</h3>
            <pre>class Point{
public:
    Point(int x,int y){
        this->x = x;
        this->y = y;
    }
private:
    int x , y ;
};
</pre>
          </section>
          <section>
            <h3>应用this指针</h3>
            <pre>Queue q1（“青年组”），q2（“中老年组”）；
Person p1("张三",20),p2("李四",50);
p1.groupTo(&q1);
p2.groupTo(&q2);

Person persons[100];
for(int i=0;i<100;i++){
    if ( persons[i].age >=45 ){
        persons[i].groupTo(&q2);
    }else{
        persons[i].groupTo(&q1);
    }
}</pre>
          </section>
          <section>
            <pre>class Queue{
public:
    void append(Person *p);
};

class Person{
public:
    void groupTo(Queue* queue);
};

void Person::groupTo( Queue* queue ){
    this->group = queue;
    
    queue->append( ??? );
}
</pre>
          </section>
          <section>
            <pre>void Person::groupTo( Queue* queue ){

    this->group = queue;
    
    queue->append( this );
    
}
</pre>
          </section>
          <section>
            <h3>应用this指针(链式调用)</h3>
            <pre>q1->append(&p1);
q1->append(&p2);

q1->append(&p1)->append(&p2);
</pre>
          </section>
          <section>
            <h3>应用this指针(链式调用)</h3>
            <pre>Queue* Queue::append(Person *p){
    ...
    return this;
}
</pre>
          </section>
        </section>
        <section>
          <section>
            <h3>【练习7-4】改进Stack</h3>
            <h3>利用链表 实现 自动扩容</h3>
          </section>
          <section>
            <h3>copy构造函数</h3>
            <pre>class Stack{
public:
    Stack(Stack & old){
       ...
    }
};
</pre>
          </section>
          <section>
            <h3>copy构造函数的调用时机</h3>
            <pre>Stack s1;

//显式调用copy构造函数
Stack s2 = s1;
Stack s3(s1);
</pre>
          </section>
          <section>
            <h3>copy构造函数的调用时机</h3>
            <pre>void foo(Stack s){
    ...
}

Stack s1;

//隐式调用copy构造函数
foo(s1);

</pre>
          </section>
          <section>
            <h3>copy构造函数的调用时机</h3>
            <pre>Stack foo(){
    Stack s;
    ...
    return s;
}
Stack s1;

//隐式调用copy构造函数
s1 = foo();
</pre>
          </section>
          <section>
            <h3>copy构造函数的调用时机</h3>
            <pre>Stack s1,s2;

s2 = s1; //赋值运算，不调用拷贝构造函数

</pre>
          </section>
        </section>
      </div>
      <div id="clock"></div>
    </div>
    <script src="js/reveal.min.js"></script>
    <script src="../lib/jquery-1.10.2.min.js"></script>
    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
          controls: true,
          progress: true,
          history: true,
          center: true,
          loop: true,
          mouseWheel: true,
          //theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
          transition: 'default' // default/cube/page/concave/zoom/linear/fade/none
          });
    </script>
    <script>
      $(function(){
          function showTime(){
              var now = new Date()
              clock.html( now.getHours()+':'+now.getMinutes() )
          }
          
          var clock = $('#clock')
          showTime()
          setInterval( showTime,1000*60 )
          
      })
    </script>
  </body>
</head>