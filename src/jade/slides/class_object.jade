//
   User: luckystar
   Date: 13-9-11
   Time: 下午3:03

extends base

block title
    title Class & Object

block slides
    section
        h1 Class & Object
        br
        h2 (类 与 对象)

    section
        section
            h3 Encapsulation
            br
            h3 (封装)
        section
            h3 【例1】Queue(队列)
            br
            ul
                li.fragment append(入队)
                li.fragment pop(出队)
                br
                li.fragment 队列是否满
                li.fragment 队列是否空
        section
            h3 使用 Queue类和对象
            pre.
                Queue queue;
                if ( !queue.isFull() ) {
                    queue.append ( 100 ) ;
                }

                int n ;
                if ( !queue.isEmpty() ) {
                    n = queue.pop ( ) ;
                }
                ...
                Queue *p = new Queue() ;
                p -> append ( 100 ) ;
                p = &queue ;
                ...

        section
            h3 define/declare(定义/声明）: Queue类 （ Queue.h ）
            pre.
                class Queue{

                public:
                    void append ( int item ) ;
                    int pop ( ) ;
                    bool isEmpty ( ) ;
                    bool isFull ( ) ;
            pre.fragment.
                private:
                    int data[ 100] ;
                    int head = 10 ;
                    int tail = 10 ;
                };
        section
            h3 implement(实现) Queue类 ( Queue.cpp )
            pre.
                #include “Queue.h”

                void Queue::append( int item ){
                    data[ head ] = item;
                    head = (head+1) % 100;
                }
                int Queue::pop(){
                    tail = ( tail + 1 ) % 100 ;
                    return data[ tail-1 ] ;
                }
                bool Queue::isEmpty(){
                    return (head == tail);
                };
                bool Queue::isFull(){
                    return ((head+1)%100 == tail);
                };
        section
            h3 【课堂练习7-1】Stack类
            br
            ul
                li LIFO(后进先出,FILO)
                br
                li 可容纳100个元素(int型)
                br
                li 可判断是否为空
                br
                li 可判断是否已满
                br
                li push(进栈)操作
                br
                li pop(出栈)操作
    section
        section
            h3 constructor/deconstuctor
            br
            h3 (构造/析构)
        section
            h3 改进Stack类
            br
            h3 初始化的时候确定最大容量
            pre.
                Stack stack(10000);
                ...
            .fragment
                pre.
                    Stack.h:

                    class Stack{
                    public:
                        Stack(int capbility);// 构造函数
            pre.fragment.
                private:
                    int* data;
                };
        section
            pre.
                在Stack.cpp中实现:

                Stack::Stack(int capbility){
                    data = new int[capbility];
                }
            br
            .fragment
                pre.
                    或者直接在Stack.h中实现:

                    class Stack{
                    public:
                        Stack(int capbility){
                            data = new int[capbility];
                        }
                        ...
                    }
        section
            pre.
                Point(int x, int y){
                    this->x = x;
                    this->y = y;
                }
            br
            .fragment
                pre.
                    利用初始化列表:

                    Point(int x, int y):x(x),y(y) {}
        section
            h3  单参数构造函数 实例化对象的写法
            pre.
                Stack s(100);
                //等价于
                Stack s=100;
        section
            pre.
                void foo(){
                    Stack s(10000);
                }

                ???
            pre.fragment.
                内存泄漏！！！
        section
            pre.
                class Stack{
                    public:
                        Stack(int capbility){
                            data = new int[capbility];
                        }
                        ~Stack(){ //析构函数
                            delete [] data;
                        }
                    }

        section
            h3 【课堂练习7-2】安全数组(1)
            br
            ul
                li 数组满时，不能追加元素
                br
                li 数组下标越界时，报错！
        section
            h3 【课堂练习7-3】安全数组(2)
            br
            ul
                li 数组满时，自动扩容
        section
            h3 默认（缺省）构造函数
            pre.
                int main(){
                    Point p;
                    ...
                }
                class Point{
                public:
                    //无构造函数
                private:
                    int x, y;  //x和y为随机数
                };

        section
            h3 默认（缺省）构造函数
            pre.
                int main(){
                    Point p;
                    ...
                }
                class Point{
                public:
                    //无构造函数
                private:
                    int x =0 , y = 0;
                };

        section
            h3 默认（缺省）构造函数
            pre.
                int main(){
                    Point p;
                    ...
                }
                class Point{
                public:
                    //有不带参数的构造函数
                    Point():x(0),y(0){}

                private:
                    int x , y ;
                };

        section
            h3 默认（缺省）构造函数
            pre.
                int main(){
                    Point p;  // 错误！
                    ...
                }
                class Point{
                public:
                    // 只有带参数构造函数，没有不带参数的构造函数
                    Point(int x,int y):x(x),y(y){}
                private:
                    int x , y ;
                };

        section
            h3 How about 默认析构函数？
    section
        section
            h3 this 指针
            pre.
                class Point{
                public:
                    Point(int x,int y){
                        this->x = x;
                        this->y = y;
                    }
                private:
                    int x , y ;
                };

        section
            h3 this 指针
            pre.
                class Point{
                public:
                    Point(int x,int y){
                        this->x = x;
                        this->y = y;
                    }
                private:
                    int x , y ;
                };

        section
            h3 应用this指针
            pre.
                Queue q1（“青年组”），q2（“中老年组”）；
                Person p1("张三",20),p2("李四",50);
                p1.groupTo(&q1);
                p2.groupTo(&q2);

                Person persons[100];
                for(int i=0;i<100;i++){
                    if ( persons[i].age >=45 ){
                        persons[i].groupTo(&q2);
                    }else{
                        persons[i].groupTo(&q1);
                    }
                }
        section
            pre.
                class Queue{
                public:
                    void append(Person *p);
                };

                class Person{
                public:
                    void groupTo(Queue* queue);
                };

                void Person::groupTo( Queue* queue ){
                    this->group = queue;

                    queue->append( ??? );
                }

        section
            pre.
                void Person::groupTo( Queue* queue ){

                    this->group = queue;

                    queue->append( this );

                }

        section
            h3 应用this指针(链式调用)
            pre.
                q1->append(&p1);
                q1->append(&p2);

                q1->append(&p1)->append(&p2);

        section
            h3 应用this指针(链式调用)
            pre.
                Queue* Queue::append(Person *p){
                    ...
                    return this;
                }

    section
        section
            h3 【练习7-4】改进Stack
            h3 利用链表 实现 自动扩容

        section
             h3 copy构造函数
             pre.
                 class Stack{
                 public:
                     Stack(Stack & old){
                        ...
                     }
                 };

        section
            h3 copy构造函数的调用时机
            pre.
                Stack s1;

                //显式调用copy构造函数
                Stack s2 = s1;
                Stack s3(s1);

        section
            h3 copy构造函数的调用时机
            pre.
                void foo(Stack s){
                    ...
                }

                Stack s1;

                //隐式调用copy构造函数
                foo(s1);


        section
            h3 copy构造函数的调用时机
            pre.
                Stack foo(){
                    Stack s;
                    ...
                    return s;
                }
                Stack s1;

                //隐式调用copy构造函数
                s1 = foo();

        section
            h3 copy构造函数的调用时机
            pre.
                Stack s1,s2;

                s2 = s1; //赋值运算，不调用拷贝构造函数


